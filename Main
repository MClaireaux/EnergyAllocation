
###### LOAD DATA ################################################
# set working directory
setwd("G:/PhD/Data/Energy allocation model")

#Load data
nssh1<-read.table('Main1935.txt', dec='.', sep='\t', header=TRUE)
nssh2<-read.table('Main1944.txt', sep='\t', header=TRUE, dec='.')

#Select Year, Month, Day, Region,Location, FishNb, Weight.Vol, Measure, Length,Age,OtolithOrScale,Sex,GZmm, Cohort
nssh1.2 <- nssh1[,c(1,10:13,16,17,18,20,25,29,45:57)]
nssh2.2<- nssh2[,c(1,10:13,16,17,18,20,25,29,45:57)]

str(nssh1.2)
str(nssh2.2)

#Select only the lines with scale data
nssh1.3<-subset(nssh1.2,OtolithOrScale=='S')
nssh2.3<-subset(nssh2.2,OtolithOrScale==c('S','SO'))

str(nssh1.3)
str(nssh2.3)

#Converting needed variables from numeric to factor
nssh2.3$Sex<-as.factor(nssh2.3$Sex)
nssh1.3$Sex<-as.factor(nssh1.3$Sex)

nssh2.3$Type<-as.factor(nssh2.3$Type)
nssh1.3$Type<-as.factor(nssh1.3$Type)

nssh2.3$Cohort<-as.factor(nssh2.3$Cohort)
nssh1.3$Cohort<-as.factor(nssh1.3$Cohort)



#Binding the two datasets
NSSH <- rbind(nssh1.3
              ,nssh2.3)
NSSH1<-unique(NSSH) #NSSH2 <- NSSH[!duplicated(NSSH), ]

dim(NSSH1)

#Select lines with valid weight data
NSSH1 <- subset(NSSH1, Weight.Vol=='RndWeight')
NSSH1$IndNum <- c(1:dim(NSSH1)[1])


######## Table organisation ######
library('reshape')
library('lattice')

#Organising the length of scale data from nine to two columns (one for number )
GZ <- melt(NSSH1[,c(14:23,25)], id="IndNum") #1:6

GZ1 <- melt(NSSH1[,c(9,14:23)], id="Length") #1:6

GZ2 <- melt(NSSH1[,c(14:24)], id="Cohort") #1:6

GZ3 <- melt(NSSH1[,c(10,14:23)], id="Age") #1:6

GZ4 <- melt(NSSH1[,c(8,14:23)], id="Measure") #1:6

GZ5 <- melt(NSSH1[,c(11,14:23)], id="Type") #1:6

#Building the table
data <- cbind(GZ,GZ1$Length,GZ2$Cohort,GZ3$Age,GZ4$Measure,GZ5$Type)

names(data)<-c('IndNum','ScaleInc','IncValue','Length','Cohort','MaxAge','Weight','Type')
levels(data$ScaleInc)<- c('1','2','3','4','5','6','7','8','9','Tot')

#Putting data on the right type
data$IncValue <- as.numeric(data$IncValue)
data$Length <- as.numeric(data$Length)
data$MaxAge <- as.numeric(data$MaxAge)
data$Cohort <- as.factor(data$Cohort)
data$IndNum <- as.numeric(data$IndNum)
data$Type <- as.factor(data$Type)

data<-data[complete.cases(data[,3]),]

#Create a column for age corresponding to scale Inc
names(data)[2]<-c('Age')


#IncValue-Weight relationship 
#Organise the table relatively to the cohorts
dataTOT<-subset(data, Age == 'Tot')
dataTOT<-dataTOT[order(dataTOT$Cohort),]

############## Back-calculation #####################
#Relationship between Increment value and length

data.list.BC<-lapply(unique(dataTOT$Cohort),
                     FUN=function (c) {
                       result = tryCatch(
                         lm(IncValue~Length,data=subset(dataTOT,Cohort==c)),
                         error = function(e) NA
                       )
                     }
)

names(data.list.BC) <- unique(dataTOT$Cohort)

#Value extraction
data.coh.BC<-t(sapply(which(!is.na(data.list.BC)),FUN=function (i) coef(data.list.BC[[i]])))
data.coh.BC<-as.data.frame(data.coh.BC)
rownames(data.coh.BC)<-unique(dataTOT$Cohort)[which(!is.na(data.list.BC))] #Changement du nom des lignes
data.coh.BC$Cohort<-unique(dataTOT$Cohort)[which(!is.na(data.list.BC))] #Ajout d'une colonne cohorte
names(data.coh.BC)<-c('a', 'b','Cohort')

xyplot(dataTOT$Length~dataTOT$IncValue|as.factor(dataTOT$Cohort),cex=0.5, pch=20,xlab="Increment value",ylab="Length", main="Length~Increment value")

#Including the a and b estimates in the table
data.Pred.BC <- merge(data, data.coh.BC)

#Scale size at capture
ScTable <- subset(dataTOT, select=c('IncValue','Cohort','IndNum','MaxAge','Weight'))
names(ScTable)[1]<- 'Sc'
dataTable <- merge(ScTable,data.Pred.BC)

#Function to predict Lt
XFun <- function(Lc,Sc,Si,a,b) {
  -(a/b)+((Lc+(a/b))*Si)/Sc
}

#Apply function
Pred.BC <- apply(dataTable, 2, function(v,w,x,y,z) XFun(Lc=dataTable$Length,Sc=dataTable$Sc,Si=dataTable$IncValue,a=dataTable$a,dataTable$b))
Pred.BC <- as.data.frame(Pred.BC)
names(Pred.BC)[1]<-c('Lt')

#Put the estimated length in a table
data.1983$Lt <- Pred.BC$Lt

##Length Weight relationship
#Starting values for a and b
mod.start <- lm(log(Weight)~log(Length),data=subset(dataTable, Age == 'Tot')
summary(mod.start)
# 
b <- exp(coef(mod.start)[1]) #Intercept
a <- coef(mod.start)[2] #Slope


#Weight / Length relationship for all cohorts
data.list.LW<-lapply(unique(dataTOT$Cohort),
                   FUN=function (c) {
                     result = tryCatch(
                       nls(Weight~b*Length^(a) + 0,data=subset(dataTOT,Cohort==c),start=list(a=a,b=b)),
                      error = function(e) NA
                    )
                  }
 )
 

 names(data.list.LW) <- unique(dataTOT$Cohort)

data.LW<-t(sapply(which(!is.na(data.list.LW)),FUN=function (i) coef(data.list.LW[[i]])))
data.LW<-as.data.frame(data.LW)
rownames(data.LW)<-unique(dataTOT$Cohort)[which(!is.na(data.list.LW))] #Changement du nom des lignes
data.LW$Cohort<-unique(dataTOT$Cohort)[which(!is.na(data.list.LW))] #Ajout d'une colonne cohorte
names(data.LW)<-c('aW', 'bW','Cohort')

data.PredLW <- merge(dataTable, data.LW)


#Function to predict weights
LWFun <- function(Z,a,b) {
  b*Z^a
}

#Apply function
PredLW <- apply(data.PredLW, 2, function(x,y,z) LWFun(Z=data.PredLW$Lt,a=data.PredLW$aW,b=data.PredLW$bW))
PredLW <- as.data.frame(PredLW)
names(PredLW)[1]<-c('Wt')

#Put the estimated weight in a table
dataTable$Wt <- PredLW$Wt





##################### TODO  ########################
########################### Model ######################################


data.Pred.New <-subset(data.1983, Age!=10 & MaxAge > 5)
data.Pred.New<-data.Pred.New[order(data.Pred.New$Cohort),]

dataTOT<-dataTOT[order(dataTOT$Cohort),]

######### Model
library(fBasics)
library(nlme)
#Estimate W1

# data.try<-lapply(unique(data.Pred.New$Cohort),
#                   FUN=function (c) {
#                     result = tryCatch(
#                       mean(subset(data.Pred.New, Cohort==c)$Pred.Pow[subset(data.Pred.New, Cohort==c)$Age==1]),
#                       error = function(e) NA
#                     )
#                   }
# )
# names(data.try) <- unique(data.Pred.New$Cohort)
# 
# data.w1<-t(sapply(which(!is.na(data.try)),FUN=function (i) data.try[[i]]))
# data.w1<-as.data.frame(data.w1)
# data.w1 <- as.data.frame(t(data.w1))
# 
# data.w1$Cohort<-unique(data.Pred.New$Cohort) #Ajout d'une colonne cohorte
# 
# data.Pred.New <- merge(data.Pred.New,data.w1)
# names(data.Pred.New)[1] <- 'w1'

w1.data <- subset(data.Pred.New, Age==1)
w1 <- mean(w1.data$Wt)
#### Fonction pour les jeunes

mj <- function(a=0.67,A2,t) {
  (14.89^(1-a))+A2*(1-a)*(t-1)
}

#### Fonction pour les adultes

ma <- function(a=0.67,A2,C2,t,tmat2) {
  (A2/C2)-((A2/C2)-mj(t=tmat2,A2=A2))*exp(-C2*(1-a)*((t-1)-tmat2))
}


####Fonction globale

mod <- function(A2,t,C2,tmat2) {
  (1-Heaviside(t-tmat2, a=0))*mj(A2=A2,t=t)+Heaviside(t-tmat2, a=0)*ma(A2=A2,t=t,C2=C2,tmat2=tmat2)
}

#### Estimation de A
#On considère la première partie de la courbe de croissance (avant tmat) linéaire
#Avec A la pente de cette droite (on considère les âges 1 et 2 uniquement pour avoir la partie avant mat)
#Sachant l'équation d'une pente : A = (y2-y1)/(x2-x1) d'où
#Poids aux âges 1 et 2
P1 <- mean(na.omit(dataTOT.1983$Weight[dataTOT.1983$MaxAge==0]))
P2 <- mean(na.omit(dataTOT.1983$Weight[dataTOT.1983$MaxAge==1]))

A2 <- (P2-w1)

#On fait la moyenne
A.start <- A2

####Estimation de C
#On considère l'asymptote de la courbe de croissance avec winf^(1-a) le poids asymptotique.
#a est fixé à 0.67
#winf est estimé à partir de nos données pour les derniers âges (on prend de 13 à 18 pour un echantillon suffisamment grand)
#Sachant que winf^(1-a) = A/C
w23 <- data.1983$Weight[data.1983$MaxAge==19]
w22 <- data.1983$Weight[data.1983$MaxAge==18]


winf <- mean(c(w23,w22))

C.start <- A.start/(winf^0.33)


#####Estimation tmat

tmat.start1<- mean(na.omit(nssh1$SpawningAge))
tmat.start2<- mean(na.omit(nssh2$SpawningAge))

tmat.start<-mean(tmat.start1,tmat.start2)

########Résumé
A2<-A.start
C2 <- C.start
tmat2 <- tmat.start


###Modèle par cohorte non linéaire
# estim.list.t<-lapply(unique(subset(dataTOT, Cohort==1930)),
#                      FUN=function (c) {
#                        result = tryCatch(
#                          summary(nls(I(Pred.Pow^0.33)~mod(wo=w1,A2=A2,C2=C2,tmat2=tmat2,t=Age),data=subset(data.Pred.New,Cohort==c),
#                                      start=list(A2=A2,C2=C2,tmat2=tmat2), control=nls.control(maxiter = 50, tol = 1e-03, minFactor = 1/2048,printEval = T, warnOnly =T))),
#                          error = function(e) NA)
#                      })
# 
# names(estim.list.t)<-unique(dataTOT$Cohort)

TRY.nls<-nls(I(Wt^0.33)~mod(A2=A2,C2=C2,tmat2=as.numeric(tmat2),t=as.numeric(Age)),data=data.Pred.New,start=list(A2=A2,C2=C2,tmat2=tmat2))

TRY.nlme <- nlme(I(Wt^0.33)~mod(A2=A2,C2=C2,tmat2=as.numeric(tmat2),t=as.numeric(Age)),data=data.Pred.New, 
                 fixed = A2 + C2 + tmat2 ~ 1, random = A2 + C2 + tmat2~ 1|IndNum , start=list(fixed=c(A2=A.start,C2=C.start,tmat2=tmat.start)))
